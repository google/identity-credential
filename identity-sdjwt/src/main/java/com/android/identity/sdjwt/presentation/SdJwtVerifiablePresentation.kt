package com.android.identity.sdjwt.presentation

import com.android.identity.crypto.Crypto
import com.android.identity.crypto.EcPublicKey
import com.android.identity.crypto.EcSignature
import com.android.identity.sdjwt.SdJwtVerifiableCredential
import com.android.identity.sdjwt.vc.JwtBody
import com.android.identity.util.fromBase64
import com.android.identity.util.toBase64
import kotlinx.datetime.Instant

/**
 * A presentation of a SD-JWT. It consists of:
 * (1) an SD-JWT (which itself has the form
 *     <header>.<body>.<signature>~<disclosure>...~<disclosure>~
 *     )
 * (2) a key binding header followed by a period
 * (3) a key binding body followed by a period
 * (4) a signature over the key binding header and key binding body
 *
 * The last three components are called a "Key Binding JWT".
 *
 */
class SdJwtVerifiablePresentation(
    val sdJwtVc: SdJwtVerifiableCredential,
    val keyBindingHeader: String,
    val keyBindingBody: String,
    val keyBindingSignature: String,
) {

    fun getAttributeValue(key: String) = sdJwtVc.getAttributeValue(key)

    private fun verifyHolderSignature(key: EcPublicKey): KeyBindingBody {
        val keyBindingHeaderObj = KeyBindingHeader.fromString(keyBindingHeader)
        val keyBindingBodyObj = KeyBindingBody.fromString(keyBindingBody)

        // compare the hash of the VC against what's in the key binding JWT
        val sdHash = Crypto.digest(sdJwtVc.sdHashAlg, sdJwtVc.toString().toByteArray()).toBase64
        if (sdHash != keyBindingBodyObj.sdHash) {
            throw IllegalStateException("hash in key binding JWT didn't match SD-JWT")
        }

        val toBeVerified = "$keyBindingHeader.$keyBindingBody".toByteArray(Charsets.US_ASCII)
        val signature = EcSignature.fromCoseEncoded(keyBindingSignature.fromBase64)

        if (!Crypto.checkSignature(key, toBeVerified, keyBindingHeaderObj.algorithm, signature)) {
            throw IllegalStateException("Signature verification failed")
        }

        return keyBindingBodyObj
    }

    /**
     * Verifies that the SD-JWT presentation contains a key binding JWT that is signed
     * by the public key mentioned in the SD-JWT, proving that the presentation was
     * generated by the principal to which the SD-JWT was issued.
     *
     * The caller MUST pass in three functions that will validate the nonce, audience, and
     * creation time of the SD-JWT presentation.
     */
    fun verifyKeyBinding(
        checkNonce: (String) -> Boolean,
        checkAudience: (String) -> Boolean,
        checkCreationTime: (Instant) -> Boolean,
    ) {
        val key = JwtBody.fromString(sdJwtVc.body).publicKey?.asEcPublicKey ?:
            throw MalformedSdJwtPresentationError("couldn't parse public holder key from JWT: ${sdJwtVc.body}")
        val keyBindingBodyObj = verifyHolderSignature(key)

        if (!checkNonce(keyBindingBodyObj.nonce)) {
             throw IllegalStateException("nonce didn't verify in key binding JWT: ${keyBindingBodyObj.toString()}")
        }

        if (!checkAudience(keyBindingBodyObj.audience)) {
            throw IllegalStateException("audience didn't verify in key binding JWT: ${keyBindingBodyObj.toString()}")
        }

        if (!checkCreationTime(keyBindingBodyObj.creationTime)) {
            throw IllegalStateException("creation time didn't verify in key binding JWT: ${keyBindingBodyObj.toString()}")
        }
    }

    override fun toString() = "$sdJwtVc$keyBindingHeader.$keyBindingBody.$keyBindingSignature"

    companion object {
        fun fromString(input: String): SdJwtVerifiablePresentation {
            val lastTildePosition = input.lastIndexOf('~')

            if (lastTildePosition == -1) {
                throw MalformedSdJwtPresentationError("couldn't find ~ in SD-JWT $input")
            }

            val sdJwtString = input.substring(0, lastTildePosition + 1)
            val keyBindingJwtString = input.substring(lastTildePosition + 1)

            val sdJwt = SdJwtVerifiableCredential.fromString(sdJwtString)

            val keyBindingJwtParts = keyBindingJwtString.split(".")

            if (keyBindingJwtParts.size != 3) {
                throw MalformedSdJwtPresentationError("key binding JWT didn't consist of three parts: $keyBindingJwtString")
            }

            val (keyBindingHeader, keyBindingBody, keyBindingSignature) = keyBindingJwtParts

            return SdJwtVerifiablePresentation(
                sdJwt,
                keyBindingHeader,
                keyBindingBody,
                keyBindingSignature)
        }
    }

    class MalformedSdJwtPresentationError(message: String): Exception(message)
}