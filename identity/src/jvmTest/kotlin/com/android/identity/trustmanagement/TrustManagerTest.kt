package com.android.identity.trustmanagement

import com.android.identity.crypto.X509Cert
import org.bouncycastle.asn1.x500.X500Name
import org.bouncycastle.asn1.x509.BasicConstraints
import org.bouncycastle.asn1.x509.Extension
import org.bouncycastle.asn1.x509.KeyUsage
import org.bouncycastle.asn1.x509.SubjectPublicKeyInfo
import org.bouncycastle.cert.X509ExtensionUtils
import org.bouncycastle.cert.bc.BcX509ExtensionUtils
import org.bouncycastle.cert.jcajce.JcaX509v3CertificateBuilder
import org.bouncycastle.crypto.util.PublicKeyFactory
import org.bouncycastle.crypto.util.SubjectPublicKeyInfoFactory
import org.bouncycastle.jce.provider.BouncyCastleProvider
import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder
import org.junit.Assert
import org.junit.Test
import java.io.ByteArrayInputStream
import java.math.BigInteger
import java.security.KeyPairGenerator
import java.security.cert.CertificateFactory
import java.security.cert.X509Certificate
import java.security.spec.ECGenParameterSpec
import java.util.Date


class TrustManagerTest {
    // Generated by first generating a new mdlCaCertificatePem (see below), then:
    // $ ./gradlew --quiet runIdentityCtl --args \
    //   "generateDs --iaca_certificate iaca_certificate.pem \
    //   --iaca_private_key iaca_private_key.pem --validity_in_years 10"
    // Then copy the contents of the identityctl/ds_certificate.pem file here.
    val mdlDsCertificatePem = """
        -----BEGIN CERTIFICATE-----
        MIICojCCAiegAwIBAgIQFHtQEncyjom+wHkUPyfqLDAKBggqhkjOPQQDAjA5MQswCQYDVQQGEwJa
        WjEqMCgGA1UEAwwhT1dGIElkZW50aXR5IENyZWRlbnRpYWwgVEVTVCBJQUNBMB4XDTI0MTAyOTIx
        MDg0MloXDTM0MTAyOTIxMDg0MlowNzEoMCYGA1UEAwwfT1dGIElkZW50aXR5IENyZWRlbnRpYWwg
        VEVTVCBEUzELMAkGA1UEBhMCWlowWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAASaYTJ+iguH3Pp1
        wY8bATG5J+7C1I8U6AqN0rKgBeT7RpY28EaC2HrmTV4Boidefc+C5J2hkDTjch9/pqZuRP+uo4IB
        ETCCAQ0wHQYDVR0OBBYEFKF8D5k9cD+GezyhAik3HOCTlyXoMB8GA1UdIwQYMBaAFEJo12Nqz57b
        TrgLa1Iw8YI7gGPjMA4GA1UdDwEB/wQEAwIHgDAVBgNVHSUBAf8ECzAJBgcogYxdBQECMFQGA1Ud
        HwRNBEswSTBHoEWgQ4ZBaHR0cHM6Ly9naXRodWIuY29tL29wZW53YWxsZXQtZm91bmRhdGlvbi1s
        YWJzL2lkZW50aXR5LWNyZWRlbnRpYWwwTgYDVR0SBEcERTBDhkFodHRwczovL2dpdGh1Yi5jb20v
        b3BlbndhbGxldC1mb3VuZGF0aW9uLWxhYnMvaWRlbnRpdHktY3JlZGVudGlhbDAKBggqhkjOPQQD
        AgNpADBmAjEAlqMn2N2Pd6QnfKOcpBNYUtWlgIwVyFTafzL7BzpYXxRD4PRXBOdlX4aTqk6QUZPk
        AjEAiUooCB4aDQEoKE0DjpY3m/GNdjfThumDfxuryr8G1bPO8MVlJfsxPo63BxnmqdA4
        -----END CERTIFICATE-----
    """.trimIndent()

    // Generated by:
    // $ ./gradlew --quiet runIdentityCtl --args "generateIaca --validity_in_years 10"
    // Then copy the contents of the identityctl/iaca_certificate.pem file here.
    val mdlCaCertificatePem = """
        -----BEGIN CERTIFICATE-----
        MIICuTCCAkCgAwIBAgIRAIxlo7ajVrEgr3Cwcn6tKqwwCgYIKoZIzj0EAwMwOTEqMCgGA1UEAwwh
        T1dGIElkZW50aXR5IENyZWRlbnRpYWwgVEVTVCBJQUNBMQswCQYDVQQGEwJaWjAeFw0yNDEwMjky
        MTA4MTFaFw0zNDEwMjkyMTA4MTFaMDkxKjAoBgNVBAMMIU9XRiBJZGVudGl0eSBDcmVkZW50aWFs
        IFRFU1QgSUFDQTELMAkGA1UEBhMCWlowdjAQBgcqhkjOPQIBBgUrgQQAIgNiAASZiCZJrPJtWPfq
        4FhcVZURmxlNPcmlMIIVfjt5dxMKlIco65kf+uyDDnAdrt5f1wEOdWuKAr+iBoO/50xUtjqchOX6
        ETfHmke43lY1H19UCkuGi9SdXJWdpBeJO20QHnGjggEKMIIBBjAdBgNVHQ4EFgQUQmjXY2rPnttO
        uAtrUjDxgjuAY+MwHwYDVR0jBBgwFoAUQmjXY2rPnttOuAtrUjDxgjuAY+MwDgYDVR0PAQH/BAQD
        AgEGMEwGA1UdEgRFMEOGQWh0dHBzOi8vZ2l0aHViLmNvbS9vcGVud2FsbGV0LWZvdW5kYXRpb24t
        bGFicy9pZGVudGl0eS1jcmVkZW50aWFsMBIGA1UdEwEB/wQIMAYBAf8CAQAwUgYDVR0fBEswSTBH
        oEWgQ4ZBaHR0cHM6Ly9naXRodWIuY29tL29wZW53YWxsZXQtZm91bmRhdGlvbi1sYWJzL2lkZW50
        aXR5LWNyZWRlbnRpYWwwCgYIKoZIzj0EAwMDZwAwZAIwOFyRmLlAH8x2rVDD8j4uuhMNuldOqfLF
        uVcZgsOVIGOsYfSbWq8PJZpH3l88niUSAjBI1cdPojUMa9CFF0C6kqOE6jchM7W4OvDPh88pApg0
        uT32u4G3/NXr8L2JZTBcLOc=
        -----END CERTIFICATE-----
    """.trimIndent()

    val mdlDsCertificate: X509Certificate
    val mdlCaCertificate: X509Certificate

    val caCertificate: X509Certificate
    val intermediateCertificate: X509Certificate
    val dsCertificate: X509Certificate

    init {
        mdlDsCertificate =
            parseCertificate(mdlDsCertificatePem.byteInputStream(Charsets.US_ASCII).readBytes())
        mdlCaCertificate =
            parseCertificate(mdlCaCertificatePem.byteInputStream(Charsets.US_ASCII).readBytes())

        java.security.Security.insertProviderAt(BouncyCastleProvider(), 1)
        val extensionUtils: X509ExtensionUtils = BcX509ExtensionUtils()
        val kpg = KeyPairGenerator.getInstance("EC", BouncyCastleProvider())
        kpg.initialize(ECGenParameterSpec("secp256r1"))

        // generate CA certificate
        val keyPairCA = kpg.generateKeyPair()
        val caPublicKeyInfo: SubjectPublicKeyInfo =
            SubjectPublicKeyInfoFactory.createSubjectPublicKeyInfo(
                PublicKeyFactory.createKey(keyPairCA.public.encoded)
            )
        val nowMillis = System.currentTimeMillis()
        val certBuilderCA = JcaX509v3CertificateBuilder(
            X500Name("CN=Test TrustManager CA"),
            BigInteger.ONE,
            Date(nowMillis),
            Date(nowMillis + 24 * 3600 * 1000),
            X500Name("CN=Test TrustManager CA"),
            keyPairCA.public
        ).addExtension(Extension.basicConstraints, true, BasicConstraints(0))
            .addExtension(Extension.keyUsage, true, KeyUsage(KeyUsage.keyCertSign))
            .addExtension(
                Extension.subjectKeyIdentifier,
                false,
                extensionUtils.createSubjectKeyIdentifier(caPublicKeyInfo)
            )
        val signerCA = JcaContentSignerBuilder("SHA256withECDSA").build(keyPairCA.private)
        val caHolder = certBuilderCA.build(signerCA)
        val cf = CertificateFactory.getInstance("X.509")
        val caStream = ByteArrayInputStream(caHolder.encoded)
        caCertificate = cf.generateCertificate(caStream) as X509Certificate

        // generate intermediate certificate
        val keyPairIntermediate = kpg.generateKeyPair()
        val intermediatePublicKeyInfo: SubjectPublicKeyInfo =
            SubjectPublicKeyInfoFactory.createSubjectPublicKeyInfo(
                PublicKeyFactory.createKey(keyPairIntermediate.public.encoded)
            )
        val certBuilderIntermediate = JcaX509v3CertificateBuilder(
            X500Name("CN=Test TrustManager CA"),
            BigInteger.TWO,
            Date(nowMillis),
            Date(nowMillis + 24 * 3600 * 1000),
            X500Name("CN=Test TrustManager Intermediate"),
            keyPairIntermediate.public
        ).addExtension(Extension.basicConstraints, true, BasicConstraints(0))
            .addExtension(Extension.keyUsage, true, KeyUsage(KeyUsage.keyCertSign))
            .addExtension(
                Extension.authorityKeyIdentifier,
                false,
                extensionUtils.createAuthorityKeyIdentifier(caHolder)
            )
            .addExtension(
                Extension.subjectKeyIdentifier,
                false,
                extensionUtils.createSubjectKeyIdentifier(intermediatePublicKeyInfo)
            )

        val intermediateHolder = certBuilderIntermediate.build(signerCA)
        val intermediateStream = ByteArrayInputStream(intermediateHolder.encoded)
        intermediateCertificate = cf.generateCertificate(intermediateStream) as X509Certificate

        // generate DS certificate
        val keyPairDS = kpg.generateKeyPair()
        val dsPublicKeyInfo: SubjectPublicKeyInfo =
            SubjectPublicKeyInfoFactory.createSubjectPublicKeyInfo(
                PublicKeyFactory.createKey(keyPairDS.public.encoded)
            )
        val certBuilderDS = JcaX509v3CertificateBuilder(
            X500Name("CN=Test TrustManager Intermediate"),
            BigInteger.ONE.add(BigInteger.TWO),
            Date(nowMillis),
            Date(nowMillis + 24 * 3600 * 1000),
            X500Name("CN=Test TrustManager DS"),
            keyPairDS.public
        ).addExtension(Extension.basicConstraints, true, BasicConstraints(0))
            .addExtension(Extension.keyUsage, true, KeyUsage(KeyUsage.digitalSignature))
            .addExtension(
                Extension.authorityKeyIdentifier,
                false,
                extensionUtils.createAuthorityKeyIdentifier(intermediateHolder)
            )
            .addExtension(
                Extension.subjectKeyIdentifier,
                false,
                extensionUtils.createSubjectKeyIdentifier(dsPublicKeyInfo)
            )
        val signerIntermediate =
            JcaContentSignerBuilder("SHA256withECDSA").build(keyPairIntermediate.private)
        val dsHolder = certBuilderDS.build(signerIntermediate)
        val dsStream = ByteArrayInputStream(dsHolder.encoded)
        dsCertificate = cf.generateCertificate(dsStream) as X509Certificate
    }

    @Test
    fun testTrustManagerHappyFlow() {
        // arrange (start with a TrustManager without certificates)
        val trustManager = TrustManager()

        // act (add certificate and verify chain)
        trustManager.addTrustPoint(TrustPoint(X509Cert(mdlCaCertificate.encoded)))
        val result = trustManager.verify(listOf(mdlDsCertificate))

        // assert
        Assert.assertTrue("DS Certificate is trusted", result.isTrusted)
        Assert.assertEquals("Trust chain contains 2 certificates", 2, result.trustChain.size)
        Assert.assertEquals("Error is empty", result.error, null)
    }

    @Test
    fun testTrustManagerHappyFlowWithIntermediateAndCaCertifcate() {
        // arrange (start with a TrustManager without certificates)
        val trustManager = TrustManager()

        // act (add intermediate and CA certificate and verify chain)
        trustManager.addTrustPoint(TrustPoint(X509Cert(intermediateCertificate.encoded)))
        trustManager.addTrustPoint(TrustPoint(X509Cert(caCertificate.encoded)))
        val result = trustManager.verify(listOf(dsCertificate))

        // assert
        Assert.assertTrue("DS Certificate is trusted", result.isTrusted)
        Assert.assertEquals("Trust chain contains 3 certificates", 3, result.trustChain.size)
        Assert.assertEquals("Error is empty", result.error, null)
    }

    @Test
    fun testTrustManagerHappyFlowWithIntermediateCertifcate() {
        // arrange (start with a TrustManager without certificates)
        val trustManager = TrustManager()

        // act (add intermediate certificate (without CA) and verify chain)
        trustManager.addTrustPoint(TrustPoint(X509Cert(intermediateCertificate.encoded)))
        val result = trustManager.verify(listOf(dsCertificate))

        // assert
        Assert.assertTrue("DS Certificate is trusted", result.isTrusted)
        Assert.assertEquals("Trust chain contains 2 certificates", 2, result.trustChain.size)
        Assert.assertEquals("Error is empty", result.error, null)
    }

    @Test
    fun testTrustManagerCaCertificateMissing() {
        // arrange (start with a TrustManager without certificates)
        val trustManager = TrustManager()

        // act (verify chain)
        val result = trustManager.verify(listOf(mdlDsCertificate))

        // assert
        Assert.assertFalse("DS Certificate is not trusted", result.isTrusted)
        Assert.assertEquals("Trust chain is empty", 0, result.trustChain.size)
        Assert.assertEquals(
            "Trustmanager complains about missing CA Certificate",
            "No trusted root certificate could not be found",
            result.error?.message
        )
    }

    private fun parseCertificate(certificateBytes: ByteArray): X509Certificate {
        return CertificateFactory.getInstance("X509")
            .generateCertificate(ByteArrayInputStream(certificateBytes)) as X509Certificate
    }
}