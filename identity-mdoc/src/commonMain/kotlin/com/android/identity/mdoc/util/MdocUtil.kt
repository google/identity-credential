/*
 * Copyright 2023 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.identity.mdoc.util

import com.android.identity.cbor.Bstr
import com.android.identity.cbor.Cbor
import com.android.identity.cbor.CborMap
import com.android.identity.cbor.RawCbor
import com.android.identity.cbor.Simple
import com.android.identity.cbor.Tagged
import com.android.identity.document.DocumentRequest
import com.android.identity.document.DocumentRequest.DataElement
import com.android.identity.document.NameSpacedData
import com.android.identity.crypto.Algorithm
import com.android.identity.crypto.Crypto
import com.android.identity.mdoc.mso.StaticAuthDataParser.StaticAuthData
import com.android.identity.mdoc.request.DeviceRequestParser
import com.android.identity.util.Logger
import kotlin.random.Random

/**
 * Utilities for working with mdoc data structures.
 *
 * On the issuance-side, [generateIssuerNameSpaces] and [stripIssuerNameSpaces] can be used with
 * [com.android.identity.mdoc.mso.MobileSecurityObjectGenerator] and
 * [calculateDigestsForNameSpace] can be used to prepare PII and multiple static authentication
 * data packages (each including signed MSOs).
 *
 * On the device-side, [mergeIssuerNamesSpaces] can be used to generate the `DeviceResponse` CBOR
 * from the above-mentioned PII and static authentication data packages.
 */
object MdocUtil {
    private const val TAG = "MdocUtil"

    /**
     * Generates randoms and digest identifiers for data.
     *
     * This generates data similar to `IssuerNameSpaces` CBOR as defined in ISO 18013-5:
     *
     * ```
     * IssuerNameSpaces = { ; Returned data elements for each namespace
     *   + NameSpace =&gt; [ + IssuerSignedItemBytes ]
     * }
     *
     * IssuerSignedItemBytes = #6.24(bstr .cbor IssuerSignedItem)
     *
     * IssuerSignedItem = {
     *   "digestID" : uint, ; Digest ID for issuer data authentication
     *   "random" : bstr, ; Random value for issuer data authentication
     *   "elementIdentifier" : DataElementIdentifier, ; Data element identifier
     *   "elementValue" : DataElementValue ; Data element value
     * }
     * ```
     * except that the data is returned using a native maps and lists. The returned
     * data is a map from name spaces into a list of the bytes of the
     * `IssuerSignedItemBytes` CBOR. The digest identifies and randoms are
     * generated by this helper using the provided [Random] provider.
     *
     * @param data The name spaced data.
     * @param randomProvider A random provider used for generating digest identifiers and salts.
     * @param dataElementRandomSize The number of bytes to use for the salt for each data elements,
     * must be at least 16.
     * @param overrides Optionally, a map of namespaces into data element names into values for
     * overriding data in the provided [NameSpacedData] parameter.
     * @return The data described above.
     * @throws IllegalArgumentException if `dataElementRandomSize` is less than 16.
     */
    fun generateIssuerNameSpaces(
        data: NameSpacedData,
        randomProvider: Random,
        dataElementRandomSize: Int,
        overrides: Map<String, Map<String, ByteArray>>?
    ): Map<String, List<ByteArray>> {
        // ISO 18013-5 section 9.1.2.5 Message digest function says that random must
        // be at least 16 bytes long.
        require(dataElementRandomSize >= 16) {
            "Random size must be at least 16 bytes"
        }
        val ret = mutableMapOf<String, List<ByteArray>>()

        // Count number of data elements first.
        var numDataElements = 0
        for (nsName in data.nameSpaceNames) {
            numDataElements += data.getDataElementNames(nsName).size
        }
        val digestIds: MutableList<Long> = ArrayList()
        for (n in 0L until numDataElements) {
            digestIds.add(n)
        }
        digestIds.shuffle(randomProvider)
        val digestIt: Iterator<Long> = digestIds.iterator()
        for (nsName in data.nameSpaceNames) {
            var overridesByNameSpace: Map<String, ByteArray>? = null
            if (overrides != null) {
                overridesByNameSpace = overrides[nsName]
            }
            val list: MutableList<ByteArray> = ArrayList()
            for (elemName in data.getDataElementNames(nsName)) {
                var encodedValue: ByteArray? = data.getDataElement(nsName, elemName)
                val digestId = digestIt.next()
                val random = ByteArray(dataElementRandomSize)
                randomProvider.nextBytes(random)
                if (overridesByNameSpace != null) {
                    val overriddenValue = overridesByNameSpace[elemName]
                    if (overriddenValue != null) {
                        encodedValue = overriddenValue
                    }
                }
                val issuerSignedItem = CborMap.builder()
                    .put("digestID", digestId)
                    .put("random", random)
                    .put("elementIdentifier", elemName)
                    .put("elementValue", RawCbor(encodedValue!!))
                    .end()
                    .build()
                val encodedIssuerSignedItem = Cbor.encode(issuerSignedItem)
                val encodedIssuerSignedItemBytes = Cbor.encode(Tagged(24, Bstr(encodedIssuerSignedItem)))
                list.add(encodedIssuerSignedItemBytes)
            }
            ret[nsName] = list
        }
        return ret
    }

    /**
     * Strips issuer name spaces.
     *
     * This takes a `IssuerNameSpaces` value calculated by [generateIssuerNameSpaces]
     * and returns a similar structure except where all `elementValue` values
     * in `IssuerSignedItem` are set to `null`.
     *
     * @param issuerNameSpaces a map from name spaces into a list of `IssuerSignedItemBytes`.
     * @param exceptions a map from name spaces into a list of data element names for where
     * the `elementValue` should not be removed.
     * @return A copy of the passed-in structure where data element value is set to `null`.
     * for every data element.
     */
    fun stripIssuerNameSpaces(
        issuerNameSpaces: Map<String, List<ByteArray>>,
        exceptions: Map<String, List<String>>?
    ): Map<String, List<ByteArray>> {
        val ret = mutableMapOf<String, List<ByteArray>>()
        for (nameSpaceName in issuerNameSpaces.keys) {
            val list: MutableList<ByteArray> = ArrayList()
            var exceptionsForNamespace: List<String>? = null
            if (exceptions != null) {
                exceptionsForNamespace = exceptions[nameSpaceName]
            }
            for (encodedIssuerSignedItemBytes in issuerNameSpaces[nameSpaceName]!!) {
                val issuerSignedItem = Cbor.decode(encodedIssuerSignedItemBytes).asTaggedEncodedCbor
                if (exceptionsForNamespace != null) {
                    val elementIdentifier = issuerSignedItem["elementIdentifier"].asTstr
                    if (exceptionsForNamespace.contains(elementIdentifier)) {
                        list.add(encodedIssuerSignedItemBytes)
                        continue
                    }
                }
                val encodedIssuerSignedItem = Cbor.encode(issuerSignedItem)
                val modifiedEncodedIssuerSignedItem =
                    issuerSignedItemClearValue(encodedIssuerSignedItem)
                val modifiedEncodedIssuerSignedItemBytes = Cbor.encode(
                    Tagged(24, Bstr(modifiedEncodedIssuerSignedItem))
                )
                list.add(modifiedEncodedIssuerSignedItemBytes)
            }
            ret[nameSpaceName] = list
        }
        return ret
    }

    /**
     * Calculates all digests in a given name space.
     *
     * @param nameSpaceName the name space to pick from the `issuerNameSpaces` map.
     * @param issuerNameSpaces a map from name spaces into a list of `IssuerSignedItemBytes`.
     * @param digestAlgorithm the digest algorithm to use, for example [Algorithm.SHA256].
     * @return a map from digest identifiers to the calculated digest.
     * @throws IllegalArgumentException if the digest algorithm isn't supported.
     */
    fun calculateDigestsForNameSpace(
        nameSpaceName: String,
        issuerNameSpaces: Map<String, List<ByteArray>>,
        digestAlgorithm: Algorithm
    ): Map<Long, ByteArray> {
        val list = issuerNameSpaces[nameSpaceName]
            ?: throw IllegalArgumentException("No namespace $nameSpaceName in IssuerNameSpaces")
        val ret: MutableMap<Long, ByteArray> = LinkedHashMap()
        for (encodedIssuerSignedItemBytes in list) {
            val issuerSignedItem = Cbor.decode(encodedIssuerSignedItemBytes).asTaggedEncodedCbor
            val digestId = issuerSignedItem["digestID"].asNumber
            ret[digestId] = Crypto.digest(digestAlgorithm, encodedIssuerSignedItemBytes)
        }
        return ret
    }

    // Note: this also unwraps the bstr tagging of the IssuerSignedItem!
    private fun calcIssuerSignedItemMap(
        issuerNameSpaces: Map<String, List<ByteArray>>
    ): Map<String, Map<String, ByteArray>> {
        val ret: MutableMap<String, Map<String, ByteArray>> = LinkedHashMap()
        for (nameSpaceName in issuerNameSpaces.keys) {
            val innerMap: MutableMap<String, ByteArray> = LinkedHashMap()
            for (encodedIssuerSignedItemBytes in issuerNameSpaces[nameSpaceName]!!) {
                val issuerSignedItem = Cbor.decode(encodedIssuerSignedItemBytes).asTaggedEncodedCbor
                val elementIdentifier = issuerSignedItem["elementIdentifier"].asTstr
                innerMap[elementIdentifier] = Cbor.encode(issuerSignedItem)
            }
            ret[nameSpaceName] = innerMap
        }
        return ret
    }

    private fun lookupIssuerSignedMap(
        issuerSignedMap: Map<String, Map<String, ByteArray>>,
        nameSpaceName: String,
        dataElementName: String
    ): ByteArray? {
        val innerMap = issuerSignedMap[nameSpaceName] ?: return null
        return innerMap[dataElementName]
    }

    /**
     * Combines document data with static authentication data for a given request.
     *
     * This goes through all data element name in a given [DocumentRequest] and
     * for each data element name, looks up `documentData` and `staticAuthData`
     * for the value and if present, will include that in the result. Data elements with
     * [DocumentRequest.DataElement.doNotSend] set to `true` are ignored.
     *
     * The result is intended to mimic `IssuerNameSpaces` CBOR as defined
     * in ISO 18013-5 except that the data is returned using a native maps and lists.
     * The returned data is a map from name spaces into a list of the bytes of the
     * `IssuerSignedItemBytes` CBOR.
     *
     * @param request a [DocumentRequest] indicating which name spaces and data
     * element names to include in the result.
     * @param documentData Document data, organized by name space.
     * @param staticAuthData Static authentication data.
     * @return A map described above.
     */
    fun mergeIssuerNamesSpaces(
        request: DocumentRequest,
        documentData: NameSpacedData,
        staticAuthData: StaticAuthData
    ): Map<String, MutableList<ByteArray>> {
        val issuerSignedItemMap = calcIssuerSignedItemMap(staticAuthData.digestIdMapping)
        val issuerSignedData: MutableMap<String, MutableList<ByteArray>> = LinkedHashMap()
        for ((nameSpaceName, dataElementName, _, doNotSend) in request.requestedDataElements) {
            if (doNotSend) {
                continue
            }
            if (!documentData.hasDataElement(nameSpaceName, dataElementName)) {
                Logger.d(TAG,
                    "No data element in document for nameSpace $nameSpaceName "
                            + " dataElementName $dataElementName"
                )
                continue
            }
            val value = documentData.getDataElement(nameSpaceName, dataElementName)
            val encodedIssuerSignedItemMaybeWithoutValue =
                lookupIssuerSignedMap(issuerSignedItemMap, nameSpaceName, dataElementName)
            if (encodedIssuerSignedItemMaybeWithoutValue == null) {
                Logger.w(TAG, "No IssuerSignedItem for $nameSpaceName $dataElementName")
                continue
            }
            var encodedIssuerSignedItem: ByteArray?
            encodedIssuerSignedItem =
                if (hasElementValue(encodedIssuerSignedItemMaybeWithoutValue)) {
                    encodedIssuerSignedItemMaybeWithoutValue
                } else {
                    issuerSignedItemSetValue(encodedIssuerSignedItemMaybeWithoutValue, value)
                }
            val list = issuerSignedData.getOrPut(nameSpaceName) { ArrayList() }

            // We need a tagged bstr here
            val taggedEncodedIssuerSignedItem = Cbor.encode(Tagged(24, Bstr(encodedIssuerSignedItem)))
            list.add(taggedEncodedIssuerSignedItem)
        }
        return issuerSignedData
    }

    private fun hasElementValue(encodedIssuerSignedItem: ByteArray): Boolean =
        Cbor.decode(encodedIssuerSignedItem)["elementValue"] != Simple.NULL

    /**
     * Helper function to generate a [DocumentRequest].
     *
     * @param documentRequest a [com.android.identity.mdoc.request.DeviceRequestParser.DocRequest].
     * @return a [DocumentRequest] representing for the given [com.android.identity.mdoc.request.DeviceRequestParser.DocRequest].
     */
    fun generateDocumentRequest(
        documentRequest: DeviceRequestParser.DocRequest
    ): DocumentRequest {
        val elements: MutableList<DataElement> = ArrayList()
        for (namespaceName in documentRequest.namespaces) {
            for (dataElementName in documentRequest.getEntryNames(namespaceName!!)) {
                val intentToRetain =
                    documentRequest.getIntentToRetain(namespaceName, dataElementName!!)
                elements.add(DataElement(namespaceName, dataElementName, intentToRetain, false))
            }
        }
        return DocumentRequest(elements)
    }

    private fun issuerSignedItemClearValue(encodedIssuerSignedItem: ByteArray): ByteArray {
        val encodedNullValue = Cbor.encode(Simple.NULL)
        return issuerSignedItemSetValue(encodedIssuerSignedItem, encodedNullValue)
    }

    private fun issuerSignedItemSetValue(
        encodedIssuerSignedItem: ByteArray,
        encodedElementValue: ByteArray
    ): ByteArray {
        val map = Cbor.decode(encodedIssuerSignedItem)
        val builder = CborMap.builder()
        for (key in map.asMap.keys) {
            if (key.asTstr == "elementValue") {
                builder.put(key, RawCbor(encodedElementValue))
            } else {
                builder.put(key, map[key])
            }
        }
        return Cbor.encode(builder.end().build())
    }
}
